<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="author" content="parth_parikh">
    <meta name="description" content="This blogpost mentions an efficient method to calculate factors of any number in Python.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Finding factors in Python</title>
    <link href="./style/prism_okaidia.css" rel="stylesheet" />
    <script src="./js/prism_okaidia.js"></script>
    <link rel="stylesheet" type="text/css" href="./style/common_styles.css" id="light">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="shortcut icon" type="image/png" href="../favicon.png" />
    <noscript>
        <style>
            .off {
                display: none
            }
        </style>
    </noscript>

</head>

<body>
    <div class="blog-text">
        <script type="text/javascript" src="./js/dark_light_mode.js"></script>
        <a id="on-off" class="off" onclick="setTheme(this)" href="#">Turn on/off lights</a>
        <br class="off">
        <h1>Finding Factors in Python</h1>
        <p>An interesting question was posted on Stack Overflow dated July 23, 2011. The question was - <a
                href="https://stackoverflow.com/questions/6800193/what-is-the-most-efficient-way-of-finding-all-the-factors-of-a-number-in-python">what
                is the most efficient way of finding all the factors of a number in Python?</a></p>

        <p>Do note that the author was seeking <b>all</b> possible factors and not just the prime factors. This is a fun
            problem to solve and reminds me of a time when I used to goof around all day with <a
                href="https://projecteuler.net/">Project Euler</a> problems.</p>

        <p>The topmost answer from <u>@agf</u> is how most of us would try and approach this problem - </p>

<pre><code class="language-python">from functools import reduce

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))</code></pre>

        <p>The above code is simple, elegant, and suprisingly fast for numbers below 10<sup>16</sup>. As concisely described by @agf - the code tries all the numbers between 1 and <i>sqrt(n)</i>+1. If a number is found to divisible by <i>n</i>, the number (<i>i</i>) along with n/i are added to the list.
        </p>

        <p>Question is can we do better <b>with minimal effort</b>?</p>

        <p>GNU coreutils has a utility called <a href="https://en.wikipedia.org/wiki/Factor_(Unix)">factor</a>. As mentioned on Wikipedia - <blockquote> In some variants of Unix, it is classified as a "game" more than a serious utility, and therefore documented in section 6.</blockquote>
        Can we use this <i>game</i> to our advantage? Yes, we can! Although this utility finds <b>prime factors</b> instead of <b>all</b> factors, we can try and find all possible combinations of prime factors and get the list of factors. The utility is blazingly fast as seen in the below example -
        </p>

        <img src="./pics/factor-utility.png">

        <p>We can integrate the results into Python using the standard library <a href="http://docs.python.org/library/subprocess.html">subprocess</a> - 
        </p>

<pre><code class="language-python">import subprocess

def find_prime_factors(n):
    process = subprocess.Popen("factor {}".format(n).split(), stdout=subprocess.PIPE)
    output, error = process.communicate()
    return [int(num) for num in output.decode().split()[1:]]</code></pre>

        <p>With this, we are very close to the actual solution, all we need to do is <i>find all the numbers which can be generated by multiplying the prime factors.</i> This will provide us all the factors of that number. For example: 
            <br>num = 18
            <br>prime_factors = [2, 3, 3]

            <br>Multiplying all possible combinations of the above <i>prime_factors</i> list gives: 
            <br>(2) = 2, (3) = 3, (2,3) = 6, (3,3) = 9, (2,3,3) = 18

            <br>Adding 1 at the beginning, we get all factors of 18: [1, 2, 3, 6, 9, 18]
        </p>

        <p>The above logic can be implemented in Python as:</p>

<pre><code class="language-python">import itertools
from functools import reduce            

def all_factors(n):
    prime_factors = find_prime_factors(n)
    factors = set({1})

    # using powerset()
    # as described in https://docs.python.org/2/library/itertools.html#recipes
    combinations = itertools.chain.from_iterable(
                        itertools.combinations(prime_factors, r) 
                            for r in range(1, len(prime_factors) + 1)
                    )
    for subset in combinations:
        factors.add(reduce(lambda x, y: x*y, subset))
    return factors</code></pre>

    <p>Won't this method be inefficient if the <b>number of prime factors</b> is large?<br>
        Yes, as the number of prime factors increases, this method becomes less efficient. As taught in a probability class, the number of combinations of length <i>R</i> for a List of length <i>N</i> is <sup>N</sup>C<sub>R</sub> = <sup>N!</sup>/<sub>(R!*(N-R)!)</sub>. A good way to imagine this is by plotting 10<sup>X</sup> for a range X. For 10<sup>13</sup>, we get prime factors as 2<sup>13</sup>5<sup>13</sup>. Finding all the combinations for N=26 is not a trivial task for the above code. However, it is a breeze for the Stack Overflow code. The below chart will help visualize this -
    </p>
    <img src="./pics/factor-comparision.png">

    <p>Based on my observation, the method <i>all_factors(n)</i> can easily fetch factors when no. of prime factors (N) is less than 20. To prove this, we can find factors of randomly selected numbers between the range 1-10<sup>30</sup>. Here is a simple test case: </p>

<pre><code class="language-python">import random
import time

def test(fact, no_test_to_perform):
    max_time = 0
    for i in range(no_test_to_perform):
        begin = time.time()
        factors = fact(random.randint(1, 10**30))
        end = time.time() - begin
        max_time = max(max_time, end)
    return max_time</code></pre> 

    <p>The results for the method <i>all_factors</i> were: </p>
    <img src="./pics/all_factors_performance.png">

    <p>As we can see even for 10000 randomly chosen integers (range 1-10<sup>30</sup>), the maximum time <i>all_factors</i> took was around 7.14 seconds. This is impressive! By comparison, here is how disastrous the Stack Overflow code was on the above test: </p>
    <img src="./pics/factors_performance.png">

    <p>While this was just one test, I could have easily wasted hours without observing any improvement in its test performance.</p>

    <p>How does the command-line utility - <i>factor</i> work? From <a href="https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/factor.c">its source code</a>:
        <blockquote>
            Algorithm:<br>
          
              (1) Perform trial division using a small primes table, but without hardware
                  division since the primes table store inverses modulo the word base.
                  (The GMP variant of this code doesn't make use of the precomputed
                  inverses, but instead relies on GMP for fast divisibility testing.)<br>
              (2) Check the nature of any non-factored part using Miller-Rabin for
                  detecting composites, and Lucas for detecting primes.<br>
              (3) Factor any remaining composite part using the Pollard-Brent rho
                  algorithm or if USE_SQUFOF is defined to 1, try that first.
                  Status of found factors are checked again using Miller-Rabin and Lucas.<br><br>
          
              We prefer using Hensel norm in the divisions, not the more familiar
              Euclidian norm, since the former leads to much faster code.  In the
              Pollard-Brent rho code and the prime testing code, we use Montgomery's
              trick of multiplying all n-residues by the word base, allowing cheap Hensel
              reductions mod n.</blockquote>
    </p>


    <p>I will try and discuss <i>factor</i>'s implementation in a future blog post. The bottom line is, for large ranges and no. of prime factors < 20, the <i>all_factors</i> method gives a great performance. A curious reader can try and implement a hybrid model to get the best of both worlds.</p>

    <p>Also, I tried using Sympy's factorint (as mentioned by few in the Stack Overflow thread) and found it to be noticeably slower than my <i>all_factors</i> implementation.</p>

    <p>Lastly, is it considered a good practice to call a command-line utility in Python?<br>
        For production, probably not. But for small projects and solving Project Euler like problems, <a href="https://www.urbandictionary.com/define.php?term=hell%20yes">hell ye!</a>
    </p>


    <br>
        <a id="back-link" href="../blog.html">&#x2190;</a>
    </div>
    <footer>
        <hr>
        <div>
            Â© 2020 Parth Parikh.
        </div>
    </footer>

</body>

</html>